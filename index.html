<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>AR Tetris Game</title>
  
  <!-- External JavaScript Libraries via CDNs -->
  <!-- AR.js for AR functionalities -->
  <script src="https://cdn.jsdelivr.net/npm/ar.js@latest"></script>
  <!-- Three.js for 3D graphics (if needed) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- A-Frame for easy AR/VR scene creation -->
  <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
  
  <!-- Inline CSS -->
  <style>
    /* Hide the canvas element since it will be used as a texture */
    #tetrisCanvas {
      display: none;
    }
    
    /* Ensure a full-screen experience */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
    }
  </style>
</head>
<body>

  <!-- Hidden Canvas for Tetris Game Rendering -->
  <!-- This canvas will be updated with our Tetris game and used as a texture on the AR plane -->
  <canvas id="tetrisCanvas" width="300" height="600"></canvas>
  
  <!-- A-Frame AR Scene -->
  <!-- The arjs attribute integrates AR.js using the device's webcam -->
  <a-scene embedded arjs="sourceType: webcam; debugUIEnabled: false;">
    <!-- AR Camera -->
    <a-camera position="0 0 0"></a-camera>
    
    <!-- A Plane that displays the Tetris game as a texture -->
    <!-- Positioned in AR space so that it appears over the live camera feed -->
    <a-plane id="gameBoard" 
             position="0 1.5 -3" 
             rotation="0 0 0" 
             width="3" height="6" 
             material="shader: flat; src: #tetrisCanvas;">
    </a-plane>
  </a-scene>
  
  <!-- Inline JavaScript: Camera Access, Sensor Events, and Tetris Game Logic -->
  <script>
    // -------------- Camera Access --------------
    // Request camera access using getUserMedia. Although AR.js handles the video feed,
    // this snippet ensures that we log access or errors.
    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      navigator.mediaDevices.getUserMedia({ video: true })
        .then(function(stream) {
          console.log("Camera access granted.");
          // The video stream is managed by AR.js automatically.
        })
        .catch(function(err) {
          console.error("Camera access denied:", err);
        });
    } else {
      console.error("getUserMedia not supported on this device.");
    }
    
    // -------------- Device Orientation & Motion Controls --------------
    // Global variables to store sensor values.
    let deviceGamma = 0; // left-right tilt
    let deviceBeta = 0;  // forward-back tilt

    // Listen for device orientation changes.
    window.addEventListener("deviceorientation", function(event) {
      // Gamma (left-to-right tilt) and Beta (front-to-back tilt)
      deviceGamma = event.gamma;
      deviceBeta = event.beta;
      // Uncomment to debug sensor values:
      // console.log("Gamma:", deviceGamma, "Beta:", deviceBeta);
    }, true);

    // -------------- Tetris Game Logic --------------
    // Setup canvas and context for drawing the Tetris game.
    const canvas = document.getElementById('tetrisCanvas');
    const context = canvas.getContext('2d');
    const COLS = 10;                     // Number of columns in the grid
    const ROWS = 20;                     // Number of rows in the grid
    const BLOCK_SIZE = canvas.width / COLS;
    let dropInterval = 1000;             // Interval (in ms) for automatic drop
    let lastDropTime = Date.now();
    
    // Create an empty grid.
    let grid = [];
    for (let row = 0; row < ROWS; row++) {
      grid[row] = [];
      for (let col = 0; col < COLS; col++) {
        grid[row][col] = 0;
      }
    }

    // Define Tetris pieces (tetrominoes) as matrices.
    const pieces = {
      'I': [
        [0,0,0,0],
        [1,1,1,1],
        [0,0,0,0],
        [0,0,0,0]
      ],
      'J': [
        [1,0,0],
        [1,1,1],
        [0,0,0]
      ],
      'L': [
        [0,0,1],
        [1,1,1],
        [0,0,0]
      ],
      'O': [
        [1,1],
        [1,1]
      ],
      'S': [
        [0,1,1],
        [1,1,0],
        [0,0,0]
      ],
      'T': [
        [0,1,0],
        [1,1,1],
        [0,0,0]
      ],
      'Z': [
        [1,1,0],
        [0,1,1],
        [0,0,0]
      ]
    };

    // Color mapping for each piece.
    const pieceColors = {
      'I': '#00f0f0',
      'J': '#0000f0',
      'L': '#f0a000',
      'O': '#f0f000',
      'S': '#00f000',
      'T': '#a000f0',
      'Z': '#f00000'
    };

    // The current falling piece.
    let currentPiece = {
      shape: null,
      x: 0,
      y: 0,
      type: null
    };

    // Generate a new random Tetris piece.
    function newPiece() {
      const types = Object.keys(pieces);
      const randType = types[Math.floor(Math.random() * types.length)];
      currentPiece.shape = pieces[randType];
      currentPiece.type = randType;
      // Center the piece horizontally at the top of the grid.
      currentPiece.x = Math.floor((COLS - currentPiece.shape[0].length) / 2);
      currentPiece.y = 0;
    }
    
    // Check if placing the piece with a given offset results in a collision.
    function collision(piece, grid, offsetX, offsetY) {
      for (let y = 0; y < piece.shape.length; y++) {
        for (let x = 0; x < piece.shape[y].length; x++) {
          if (piece.shape[y][x]) {
            let newX = piece.x + x + offsetX;
            let newY = piece.y + y + offsetY;
            // Check boundaries.
            if (newX < 0 || newX >= COLS || newY >= ROWS) {
              return true;
            }
            // Check if grid cell is already occupied.
            if (newY >= 0 && grid[newY][newX]) {
              return true;
            }
          }
        }
      }
      return false;
    }

    // Merge the current piece into the grid.
    function mergePiece(piece, grid) {
      for (let y = 0; y < piece.shape.length; y++) {
        for (let x = 0; x < piece.shape[y].length; x++) {
          if (piece.shape[y][x]) {
            if (piece.y + y >= 0) { // Ignore parts above the grid.
              grid[piece.y + y][piece.x + x] = piece.type;
            }
          }
        }
      }
    }

    // Rotate the current piece (clockwise).
    function rotate(piece) {
      const rotated = [];
      for (let x = 0; x < piece.shape[0].length; x++) {
        rotated[x] = [];
        for (let y = piece.shape.length - 1; y >= 0; y--) {
          rotated[x].push(piece.shape[y][x]);
        }
      }
      return rotated;
    }

    // Clear complete rows from the grid.
    function clearRows() {
      for (let y = ROWS - 1; y >= 0; y--) {
        if (grid[y].every(cell => cell !== 0)) {
          // Remove the full row.
          grid.splice(y, 1);
          // Add an empty row at the top.
          grid.unshift(new Array(COLS).fill(0));
          y++; // Check the same row index after shifting.
        }
      }
    }

    // Draw the game state onto the canvas.
    function draw() {
      // Clear the canvas.
      context.fillStyle = "#000";
      context.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw the static grid.
      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          if (grid[y][x]) {
            context.fillStyle = pieceColors[grid[y][x]];
            context.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            context.strokeStyle = "#111";
            context.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
          }
        }
      }
      
      // Draw the current falling piece.
      if (currentPiece.shape) {
        context.fillStyle = pieceColors[currentPiece.type];
        for (let y = 0; y < currentPiece.shape.length; y++) {
          for (let x = 0; x < currentPiece.shape[y].length; x++) {
            if (currentPiece.shape[y][x]) {
              context.fillRect((currentPiece.x + x) * BLOCK_SIZE, (currentPiece.y + y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
              context.strokeStyle = "#111";
              context.strokeRect((currentPiece.x + x) * BLOCK_SIZE, (currentPiece.y + y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            }
          }
        }
      }
    }

    // Update the game state and redraw.
    function update() {
      let now = Date.now();
      let delta = now - lastDropTime;
      if (delta > dropInterval) {
        // Attempt to move the piece down.
        if (!collision(currentPiece, grid, 0, 1)) {
          currentPiece.y++;
        } else {
          // If collision occurs, merge the piece into the grid and start a new piece.
          mergePiece(currentPiece, grid);
          clearRows();
          newPiece();
        }
        lastDropTime = now;
      }
      
      // -------------- Sensor-Based Controls --------------
      // Use left/right tilt (gamma) to move the piece horizontally.
      if (deviceGamma > 15) {  // Tilt right
        if (!collision(currentPiece, grid, 1, 0)) {
          currentPiece.x++;
          deviceGamma = 0;  // Reset to prevent continuous movement
        }
      } else if (deviceGamma < -15) {  // Tilt left
        if (!collision(currentPiece, grid, -1, 0)) {
          currentPiece.x--;
          deviceGamma = 0;
        }
      }
      
      // Use forward tilt (beta) to trigger a rotation.
      if (deviceBeta > 40) {
        let rotatedShape = rotate(currentPiece);
        let originalShape = currentPiece.shape;
        currentPiece.shape = rotatedShape;
        if (collision(currentPiece, grid, 0, 0)) {
          currentPiece.shape = originalShape; // Revert if rotation causes collision
        }
        deviceBeta = 0;
      }
      
      // Redraw the game state.
      draw();
      
      // -------------- Update AR Texture --------------
      // Mark the material texture as needing an update so the AR plane reflects changes.
      let gameBoardEl = document.querySelector('#gameBoard');
      if (gameBoardEl && gameBoardEl.components && gameBoardEl.components.material) {
        gameBoardEl.components.material.material.map.needsUpdate = true;
      }
      
      // Continue the game loop.
      requestAnimationFrame(update);
    }
    
    // Initialize the game.
    newPiece();
    update();
  </script>
</body>
</html>
