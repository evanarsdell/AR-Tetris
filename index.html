<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>3D Stick Figure Shooter</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #hud, #health {
      position: absolute;
      top: 10px;
      color: #fff;
      font-family: sans-serif;
      font-size: 20px;
      z-index: 1;
    }
    #hud { right: 10px; }
    #health { left: 10px; }
    #gameOverScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.8);
      display: none;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      color: #fff;
      font-family: sans-serif;
      z-index: 2;
    }
    #gameOverScreen button {
      padding: 10px 20px;
      font-size: 20px;
      cursor: pointer;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <div id="hud">Score: <span id="score">0</span></div>
  <div id="health">HP: <span id="hp">100</span></div>
  <div id="gameOverScreen">
    <h1>Game Over</h1>
    <p>Your Score: <span id="finalScore">0</span></p>
    <button id="restartBtn">Restart</button>
  </div>

  <!-- Three.js CDN -->
  <script src="https://unpkg.com/three@0.150.1/build/three.min.js"></script>
  <script>
    // --- Global State ---
    let scene, camera, renderer;
    let player, enemies = [], bullets = [];
    let keys = {};
    let score = 0, health = 100;
    let spawnInterval = 2000, lastSpawn = 0;
    let gameOverFlag = false;
    let lastTime = performance.now();
    const MOVE_SPEED = 10;               // units per second
    const ROTATE_SPEED = Math.PI;        // radians per second

    // --- Initialization ---
    init();
    animate(lastTime);

    function init() {
      // Scene & Camera
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      window.addEventListener('resize', onResize);

      // Lights
      scene.add(new THREE.AmbientLight(0xffffff, 0.5));
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(5, 10, 7);
      scene.add(dirLight);

      // Floor
      const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(200, 200),
        new THREE.MeshPhongMaterial({ color: 0x222222 })
      );
      floor.rotation.x = -Math.PI / 2;
      scene.add(floor);

      // Player Stick Figure with Gun
      player = createStickFigureWithGun(0x00ff00);
      scene.add(player);

      // Input Handling
      document.addEventListener('keydown', e => {
        keys[e.key.toLowerCase()] = true;
        if (e.code === 'Space' && !gameOverFlag) shoot();
      });
      document.addEventListener('keyup', e => {
        keys[e.key.toLowerCase()] = false;
      });

      // Restart Button
      document.getElementById('restartBtn').addEventListener('click', restart);
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // --- Stick Figure + Gun Factory ---
    function createStickFigureWithGun(color) {
      const group = new THREE.Group();
      const mat = new THREE.MeshPhongMaterial({ color });

      // Head
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.4, 8, 8), mat);
      head.position.y = 2.2;
      group.add(head);

      // Torso
      const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1.5, 8), mat);
      torso.position.y = 1.0;
      group.add(torso);

      // Arms
      const armGeom = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
      const leftArm = new THREE.Mesh(armGeom, mat);
      leftArm.position.set(-0.75, 1.5, 0);
      leftArm.rotation.z = Math.PI / 2;
      group.add(leftArm);
      const rightArm = leftArm.clone();
      rightArm.position.x = 0.75;
      group.add(rightArm);

      // Gun on Right Arm (same color as body so no gray)
      const gun = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.1, 0.1), mat);
      gun.position.set(1.25, 1.5, 0);
      group.add(gun);

      // Legs
      const legGeom = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
      const leftLeg = new THREE.Mesh(legGeom, mat);
      leftLeg.position.set(-0.2, 0.5, 0);
      group.add(leftLeg);
      const rightLeg = leftLeg.clone();
      rightLeg.position.x = 0.2;
      group.add(rightLeg);

      return group;
    }

    // --- Shooting ---
    function shoot() {
      const bulletMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
      const bulletGeo = new THREE.SphereGeometry(0.1, 8, 8);
      const bulletMesh = new THREE.Mesh(bulletGeo, bulletMat);

      // Direction based on player rotation
      const dir = new THREE.Vector3(
        Math.sin(player.rotation.y),
        0,
        Math.cos(player.rotation.y)
      );

      bulletMesh.position.copy(player.position)
                       .add(dir.clone().multiplyScalar(1.5))
                       .add(new THREE.Vector3(0, 1.5, 0));

      scene.add(bulletMesh);
      bullets.push({ mesh: bulletMesh, dir, life: 0 });
    }

    // --- Enemy Spawning ---
    function spawnEnemy() {
      const enemy = createStickFigureWithGun(0xff0000);
      // Scale up so they're easy to hit
      enemy.scale.set(1.5, 1.5, 1.5);

      const angle = Math.random() * Math.PI * 2;
      const distance = 50;
      enemy.position.set(
        player.position.x + Math.cos(angle) * distance,
        0,
        player.position.z + Math.sin(angle) * distance
      );
      // Speed up slightly as score climbs
      enemy.userData.speed = 1 + score * 0.01;

      scene.add(enemy);
      enemies.push(enemy);

      // Increase spawn rate
      spawnInterval = Math.max(500, spawnInterval * 0.98);
    }

    // --- Main Loop ---
    function animate(time) {
      const delta = (time - lastTime) / 1000;
      lastTime = time;

      if (!gameOverFlag) {
        // Spawn enemies
        if (time - lastSpawn > spawnInterval) {
          spawnEnemy();
          lastSpawn = time;
        }

        // Rotation via Left/Right Arrows
        if (keys['arrowleft'])  player.rotation.y += ROTATE_SPEED * delta;
        if (keys['arrowright']) player.rotation.y -= ROTATE_SPEED * delta;

        // Movement via WASD (normalized)
        let dx = 0, dz = 0;
        if (keys['w']) { dx += Math.sin(player.rotation.y); dz += Math.cos(player.rotation.y); }
        if (keys['s']) { dx -= Math.sin(player.rotation.y); dz -= Math.cos(player.rotation.y); }
        if (keys['a']) { dx += Math.sin(player.rotation.y - Math.PI/2); dz += Math.cos(player.rotation.y - Math.PI/2); }
        if (keys['d']) { dx += Math.sin(player.rotation.y + Math.PI/2); dz += Math.cos(player.rotation.y + Math.PI/2); }
        const len = Math.hypot(dx, dz);
        if (len > 0) {
          dx /= len; dz /= len;
          player.position.x += dx * MOVE_SPEED * delta;
          player.position.z += dz * MOVE_SPEED * delta;
        }
        // Keep player in bounds
        player.position.x = THREE.MathUtils.clamp(player.position.x, -50, 50);
        player.position.z = THREE.MathUtils.clamp(player.position.z, -50, 50);

        // Update bullets
        bullets = bullets.filter(b => {
          b.mesh.position.add(b.dir.clone().multiplyScalar(50 * delta));
          b.life += delta;
          if (b.life > 2) {
            scene.remove(b.mesh);
            return false;
          }
          return true;
        });

        // Update enemies
        enemies = enemies.filter(e => {
          // Move toward player
          const toPlayer = new THREE.Vector3().subVectors(player.position, e.position).normalize();
          e.position.add(toPlayer.multiplyScalar(e.userData.speed * delta));
          e.rotation.y = Math.atan2(player.position.x - e.position.x, player.position.z - e.position.z);

          // Damage on contact
          if (e.position.distanceTo(player.position) < 1) {
            health -= 10;
            updateHUD();
            scene.remove(e);
            return false;
          }

          // Bullet collision (2D check)
          for (let i = 0; i < bullets.length; i++) {
            const b = bullets[i].mesh.position;
            const exz = new THREE.Vector2(e.position.x, e.position.z);
            const bxz = new THREE.Vector2(b.x, b.z);
            if (bxz.distanceTo(exz) < 1.5) {
              score++;
              updateHUD();
              scene.remove(e);
              scene.remove(bullets[i].mesh);
              bullets.splice(i, 1);
              return false;
            }
          }
          return true;
        });

        // Check game over
        if (health <= 0) endGame();

        // Camera follows behind & above player
        const camOffset = new THREE.Vector3(
          -Math.sin(player.rotation.y) * 10,
           5,
          -Math.cos(player.rotation.y) * 10
        );
        camera.position.copy(player.position).add(camOffset);
        camera.lookAt(player.position);
      }

      renderer.render(scene, camera);
      if (!gameOverFlag) requestAnimationFrame(animate);
    }

    // --- HUD & Game State ---
    function updateHUD() {
      document.getElementById('score').innerText = score;
      document.getElementById('hp').innerText    = Math.max(0, health);
    }

    function endGame() {
      gameOverFlag = true;
      document.getElementById('finalScore').innerText = score;
      document.getElementById('gameOverScreen').style.display = 'flex';
    }

    function restart() {
      // Cleanup existing
      enemies.forEach(e => scene.remove(e));
      bullets.forEach(b => scene.remove(b.mesh));
      enemies = [];
      bullets = [];

      // Reset
      score = 0;
      health = 100;
      spawnInterval = 2000;
      lastSpawn = performance.now();
      gameOverFlag = false;
      updateHUD();
      document.getElementById('gameOverScreen').style.display = 'none';
      lastTime = performance.now();
      animate(lastTime);
    }
  </script>
</body>
</html>
