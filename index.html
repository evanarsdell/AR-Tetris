<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>3D Stick Figure Shooter</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #hud {
      position: absolute;
      top: 10px; right: 10px;
      color: #fff;
      font-family: sans-serif;
      font-size: 20px;
      z-index: 1;
    }
    #health {
      position: absolute;
      top: 10px; left: 10px;
      color: #fff;
      font-family: sans-serif;
      font-size: 20px;
      z-index: 1;
    }
    #gameOverScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.8);
      display: none;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      color: #fff;
      font-family: sans-serif;
      z-index: 2;
    }
    #gameOverScreen button {
      padding: 10px 20px;
      font-size: 20px;
      cursor: pointer;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <div id="hud">Score: <span id="score">0</span></div>
  <div id="health">HP: <span id="hp">100</span></div>
  <div id="gameOverScreen">
    <h1>Game Over</h1>
    <p>Your Score: <span id="finalScore">0</span></p>
    <button id="restartBtn">Restart</button>
  </div>

  <script src="https://unpkg.com/three@0.150.1/build/three.min.js"></script>
  <script>
    let scene, camera, renderer;
    let player, enemies = [], bullets = [];
    let keys = {};
    let score = 0, health = 100;
    let spawnInterval = 2000, lastSpawn = 0;
    let gameOverFlag = false;
    let lastTime = performance.now();
    const rotationSpeed = Math.PI; // radians per second

    init();
    animate(lastTime);

    function init() {
      // Scene & camera
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      window.addEventListener('resize', onResize);

      // Lighting
      scene.add(new THREE.AmbientLight(0xffffff, 0.5));
      const dl = new THREE.DirectionalLight(0xffffff, 0.8);
      dl.position.set(5, 10, 7);
      scene.add(dl);

      // Floor
      const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(200, 200),
        new THREE.MeshPhongMaterial({ color: 0x222222 })
      );
      floor.rotation.x = -Math.PI/2;
      scene.add(floor);

      // Player
      player = createStickFigureWithGun(0x00ff00);
      scene.add(player);

      // Input
      document.addEventListener('keydown', e => {
        keys[e.key.toLowerCase()] = true;
        if (e.code === 'Space' && !gameOverFlag) shoot();
      });
      document.addEventListener('keyup', e => {
        keys[e.key.toLowerCase()] = false;
      });

      // Restart button
      document.getElementById('restartBtn').addEventListener('click', restart);
    }

    function onResize() {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Build a stick figure with a visible gun in the right hand
    function createStickFigureWithGun(color) {
      const group = new THREE.Group();
      const mat = new THREE.MeshBasicMaterial({ color });

      // Head
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.4, 8, 8), mat);
      head.position.y = 2.2;
      group.add(head);

      // Torso
      const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1.5, 8), mat);
      torso.position.y = 1.0;
      group.add(torso);

      // Arms
      const armGeom = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
      const leftArm = new THREE.Mesh(armGeom, mat);
      leftArm.position.set(-0.75, 1.5, 0);
      leftArm.rotation.z = Math.PI/2;
      group.add(leftArm);

      const rightArm = leftArm.clone();
      rightArm.position.x = 0.75;
      group.add(rightArm);

      // Gun on right arm
      const gunMat = new THREE.MeshBasicMaterial({ color: 0x555555 });
      const gun = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.1, 0.1), gunMat);
      // position at end of right arm
      gun.position.set(1.25, 1.5, 0);
      group.add(gun);

      // Legs
      const legGeom = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
      const leftLeg = new THREE.Mesh(legGeom, mat);
      leftLeg.position.set(-0.2, 0.5, 0);
      group.add(leftLeg);

      const rightLeg = leftLeg.clone();
      rightLeg.position.x = 0.2;
      group.add(rightLeg);

      return group;
    }

    function shoot() {
      const bullet = new THREE.Mesh(
        new THREE.SphereGeometry(0.1, 8, 8),
        new THREE.MeshBasicMaterial({ color: 0xffff00 })
      );
      const dir = new THREE.Vector3(
        Math.sin(player.rotation.y),
        0,
        Math.cos(player.rotation.y)
      );
      bullet.position.copy(player.position)
                    .add(dir.clone().multiplyScalar(1.5))
                    .add(new THREE.Vector3(0, 1.5, 0));
      scene.add(bullet);
      bullets.push({ mesh: bullet, dir, life: 0 });
    }

    function spawnEnemy() {
      const enemy = createStickFigureWithGun(0xff0000);
      const angle = Math.random()*Math.PI*2;
      const dist = 50;
      enemy.position.set(
        player.position.x + Math.cos(angle)*dist,
        0,
        player.position.z + Math.sin(angle)*dist
      );
      enemy.userData.speed = 1 + score*0.01;
      scene.add(enemy);
      enemies.push(enemy);
      spawnInterval = Math.max(500, spawnInterval*0.98);
    }

    function animate(time) {
      const dt = (time - lastTime)/1000;
      lastTime = time;

      if (!gameOverFlag) {
        // spawn
        if (time - lastSpawn > spawnInterval) {
          spawnEnemy();
          lastSpawn = time;
        }

        // rotate with arrow keys
        if (keys['arrowleft'])  player.rotation.y += rotationSpeed * dt;
        if (keys['arrowright']) player.rotation.y -= rotationSpeed * dt;

        // movement WASD
        let dx = 0, dz = 0;
        if (keys['w']) { dx += Math.sin(player.rotation.y); dz += Math.cos(player.rotation.y); }
        if (keys['s']) { dx -= Math.sin(player.rotation.y); dz -= Math.cos(player.rotation.y); }
        if (keys['a']) { dx += Math.sin(player.rotation.y - Math.PI/2); dz += Math.cos(player.rotation.y - Math.PI/2); }
        if (keys['d']) { dx += Math.sin(player.rotation.y + Math.PI/2); dz += Math.cos(player.rotation.y + Math.PI/2); }
        const speed = 10;
        player.position.x += dx*speed*dt;
        player.position.z += dz*speed*dt;
        // clamp
        player.position.x = THREE.MathUtils.clamp(player.position.x, -50, 50);
        player.position.z = THREE.MathUtils.clamp(player.position.z, -50, 50);

        // bullets
        bullets = bullets.filter(b => {
          b.mesh.position.add(b.dir.clone().multiplyScalar(50*dt));
          b.life += dt;
          if (b.life > 2) { scene.remove(b.mesh); return false; }
          return true;
        });

        // enemies
        enemies = enemies.filter(e => {
          const dir = new THREE.Vector3().subVectors(player.position, e.position).normalize();
          e.position.add(dir.multiplyScalar(e.userData.speed*dt));
          e.rotation.y = Math.atan2(player.position.x - e.position.x, player.position.z - e.position.z);

          // hit player
          if (e.position.distanceTo(player.position) < 1) {
            health -= 10;
            updateHUD();
            scene.remove(e);
            return false;
          }
          // hit by bullet
          for (let i=0; i<bullets.length; i++) {
            if (bullets[i].mesh.position.distanceTo(e.position) < 1) {
              score++;
              updateHUD();
              scene.remove(e);
              scene.remove(bullets[i].mesh);
              bullets.splice(i,1);
              return false;
            }
          }
          return true;
        });

        if (health <= 0) endGame();

        // camera follow
        const offset = new THREE.Vector3(
          -Math.sin(player.rotation.y)*10, 5, -Math.cos(player.rotation.y)*10
        );
        camera.position.copy(player.position).add(offset);
        camera.lookAt(player.position);
      }

      renderer.render(scene, camera);
      if (!gameOverFlag) requestAnimationFrame(animate);
    }

    function updateHUD() {
      document.getElementById('score').innerText = score;
      document.getElementById('hp').innerText = Math.max(0, health);
    }

    function endGame() {
      gameOverFlag = true;
      document.getElementById('finalScore').innerText = score;
      document.getElementById('gameOverScreen').style.display = 'flex';
    }

    function restart() {
      // clean up
      enemies.forEach(e => scene.remove(e));
      bullets.forEach(b => scene.remove(b.mesh));
      enemies = [];
      bullets = [];

      // reset state
      score = 0;
      health = 100;
      spawnInterval = 2000;
      lastSpawn = performance.now();
      gameOverFlag = false;
      updateHUD();
      document.getElementById('gameOverScreen').style.display = 'none';
      lastTime = performance.now();
      animate(lastTime);
    }
  </script>
</body>
</html>
